<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetrahedron - 3D Visualization</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000000;
            color: #e0e0e0;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #4a90e2;
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .subtitle {
            text-align: center;
            color: #a0a0a0;
            font-size: 1.1em;
            margin-bottom: 30px;
        }
        
        .canvas-container {
            background: transparent;
            border-radius: 0;
            padding: 0;
            margin-bottom: 30px;
            box-shadow: none;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        #canvas-wrapper {
            width: 1200px;
            height: 867px;
            position: relative;
        }
        
        canvas {
            border-radius: 10px;
            cursor: grab;
            display: block;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .info-section {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 0;
            padding: 30px;
            margin-bottom: 0;
            box-shadow: none;
        }
        
        .info-section h2 {
            color: #4a90e2;
            margin-top: 0;
            font-size: 1.8em;
        }
        
        .info-section p {
            line-height: 1.8;
            font-size: 1.1em;
            color: #d0d0d0;
        }
        
        .net-container {
            text-align: center;
            margin-top: 30px;
        }
        
        .controls {
            text-align: center;
            color: #a0a0a0;
            font-size: 0.9em;
            margin-top: 15px;
        }
        
        .properties-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .property-card {
            background: rgba(74, 144, 226, 0.1);
            border-left: 4px solid #4a90e2;
            padding: 15px;
            border-radius: 8px;
        }
        
        .property-card h3 {
            margin: 0 0 10px 0;
            color: #4a90e2;
            font-size: 1.1em;
        }
        
        .property-card p {
            margin: 0;
            font-size: 1em;
            color: #d0d0d0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-container">
            <div id="canvas-wrapper"></div>
            <div style="position: absolute; top: 20px; left: 20px; background: rgba(0, 0, 0, 0.7); color: white; padding: 15px; border-radius: 8px;">
                <h2 style="font-size: 1.3em; font-weight: bold; margin: 0 0 8px 0;">Tetrahedron</h2>
                <p style="font-size: 0.9em; margin: 0;">Click and drag to rotate</p>
                <p style="font-size: 0.75em; margin: 4px 0 0 0; color: #c0c0c0;">Auto-rotates when idle</p>
            </div>
        </div>
        
        <div class="info-section">
            <h2 style="text-align: center; font-size: 1.5em;">Net of the Tetrahedron</h2>
            <div class="net-container">
                <svg width="500" height="400" viewBox="0 0 500 400" style="max-width: 100%; height: auto;">
                    <!-- Each equilateral triangle has side length 150 -->
                    <!-- Height = 150 * sqrt(3)/2 â‰ˆ 129.9 -->
                    
                    <!-- Face 1 - top triangle pointing up -->
                    <polygon points="250,50 175,179.9 325,179.9" 
                             fill="#4a90e2" stroke="#ffffff" stroke-width="3"/>
                    
                    <!-- Face 2 - bottom left triangle pointing down -->
                    <polygon points="175,179.9 100,309.8 250,309.8" 
                             fill="#4a90e2" stroke="#ffffff" stroke-width="3"/>
                    
                    <!-- Face 3 - bottom center triangle pointing up -->
                    <polygon points="175,179.9 250,309.8 325,179.9" 
                             fill="#4a90e2" stroke="#ffffff" stroke-width="3"/>
                    
                    <!-- Face 4 - bottom right triangle pointing down -->
                    <polygon points="325,179.9 250,309.8 400,309.8" 
                             fill="#4a90e2" stroke="#ffffff" stroke-width="3"/>
                </svg>
                <p style="text-align: center; margin-top: 20px; color: #d0d0d0; font-size: 1em;">
                    The net shows how the tetrahedron unfolds into a flat pattern.
                </p>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        // Camera setup
        const wrapper = document.getElementById('canvas-wrapper');
        const camera = new THREE.PerspectiveCamera(
            75,
            wrapper.offsetWidth / wrapper.offsetHeight,
            0.1,
            1000
        );
        camera.position.z = 4;

        // Renderer setup
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(wrapper.offsetWidth, wrapper.offsetHeight);
        wrapper.appendChild(renderer.domElement);

        // Create tetrahedron geometry
        const geometry = new THREE.TetrahedronGeometry(1.2, 0);

        // Create blue material like the triangular prism
        const material = new THREE.MeshPhongMaterial({
            color: 0x4a90e2,
            shininess: 100,
            specular: 0x111111,
            side: THREE.DoubleSide
        });

        const tetrahedron = new THREE.Mesh(geometry, material);
        scene.add(tetrahedron);

        // Add wireframe overlay
        const wireframeGeometry = new THREE.EdgesGeometry(geometry);
        const wireframeMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffffff, 
            linewidth: 2
        });
        const wireframe = new THREE.LineSegments(wireframeGeometry, wireframeMaterial);
        tetrahedron.add(wireframe);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.6);
        directionalLight1.position.set(5, 5, 5);
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
        directionalLight2.position.set(-5, -5, -5);
        scene.add(directionalLight2);

        const pointLight = new THREE.PointLight(0xffffff, 0.5);
        pointLight.position.set(0, 0, 5);
        scene.add(pointLight);

        // Mouse/touch interaction
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };

        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            tetrahedron.rotation.y += deltaX * 0.01;
            tetrahedron.rotation.x += deltaY * 0.01;

            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        }

        function onMouseUp() {
            isDragging = false;
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault();
                isDragging = true;
                previousMousePosition = {
                    x: event.touches[0].clientX,
                    y: event.touches[0].clientY
                };
            }
        }

        function onTouchMove(event) {
            if (!isDragging || event.touches.length !== 1) return;
            event.preventDefault();

            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            tetrahedron.rotation.y += deltaX * 0.01;
            tetrahedron.rotation.x += deltaY * 0.01;

            previousMousePosition = {
                x: event.touches[0].clientX,
                y: event.touches[0].clientY
            };
        }

        function onTouchEnd() {
            isDragging = false;
        }

        // Event listeners
        renderer.domElement.addEventListener('mousedown', onMouseDown);
        renderer.domElement.addEventListener('mousemove', onMouseMove);
        renderer.domElement.addEventListener('mouseup', onMouseUp);
        renderer.domElement.addEventListener('mouseleave', onMouseUp);
        renderer.domElement.addEventListener('touchstart', onTouchStart);
        renderer.domElement.addEventListener('touchmove', onTouchMove);
        renderer.domElement.addEventListener('touchend', onTouchEnd);

        // Handle window resize
        function onWindowResize() {
            const canvasWidth = wrapper.offsetWidth;
            const canvasHeight = wrapper.offsetHeight;
            camera.aspect = canvasWidth / canvasHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(canvasWidth, canvasHeight);
        }
        window.addEventListener('resize', onWindowResize);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            // Gentle auto-rotation when not dragging
            if (!isDragging) {
                tetrahedron.rotation.y += 0.002;
                tetrahedron.rotation.x += 0.001;
            }
            
            renderer.render(scene, camera);
        }
        animate();

        // Initial rotation for better view - shows the regular tetrahedron clearly
        tetrahedron.rotation.x = Math.PI / 6;  // 30 degrees
        tetrahedron.rotation.y = Math.PI / 4;  // 45 degrees
    </script>
</body>
</html>
